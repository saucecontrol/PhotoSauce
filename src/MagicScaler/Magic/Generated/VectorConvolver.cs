//------------------------------------------------------------------------------
//	<auto-generated>
//		This code was generated from a template.
//		Manual changes to this file will be overwritten if the code is regenerated.
//	</auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Numerics;
using System.Runtime.CompilerServices;

namespace PhotoSauce.MagicScaler
{
	unsafe internal class Convolver4ChanFloat : IConvolver
	{
		private const int Channels = 4;

		void IConvolver.ConvolveSourceLine(byte* istart, byte* tstart, int cb, byte* mapxstart, int smapx, int smapy)
		{
			float* pmapx = (float*)mapxstart;
			float* tp = (float*)tstart;
			float* tpe = (float*)(tstart + cb);
			int tstride = smapy * Channels;

			while (tp < tpe)
			{
				int ix = *(int*)pmapx++;
				float* ip = (float*)istart + ix * Channels;
				float* ipe = ip + smapx * Channels - 4 * Vector<float>.Count;
				float* mp = pmapx;
				pmapx += smapx * Channels;

				Vector<float> av0 = Vector<float>.Zero;

				while (ip <= ipe)
				{
					var iv0 = Unsafe.Read<Vector<float>>(ip);
					var iv1 = Unsafe.Read<Vector<float>>(ip + Vector<float>.Count);
					var iv2 = Unsafe.Read<Vector<float>>(ip + 2 * Vector<float>.Count);
					var iv3 = Unsafe.Read<Vector<float>>(ip + 3 * Vector<float>.Count);

					var mv0 = Unsafe.Read<Vector<float>>(mp);
					var mv1 = Unsafe.Read<Vector<float>>(mp + Vector<float>.Count);
					var mv2 = Unsafe.Read<Vector<float>>(mp + 2 * Vector<float>.Count);
					var mv3 = Unsafe.Read<Vector<float>>(mp + 3 * Vector<float>.Count);

					av0 += iv0 * mv0;
					av0 += iv1 * mv1;
					av0 += iv2 * mv2;
					av0 += iv3 * mv3;

					ip += 4 * Vector<float>.Count;
					mp += 4 * Vector<float>.Count;
				}

				float a0 = av0[0];
				float a1 = av0[1];
				float a2 = av0[2];
				float a3 = av0[3];

				if (Vector<float>.Count == 8)
				{
					a0 += av0[4];
					a1 += av0[5];
					a2 += av0[6];
					a3 += av0[7];
				}

				ipe += 4 * Vector<float>.Count;
				while (ip < ipe)
				{
					a0 += ip[0] * mp[0];
					a1 += ip[1] * mp[1];
					a2 += ip[2] * mp[2];
					a3 += ip[3] * mp[3];

					ip += Channels;
					mp += Channels;
				}

				tp[0] = a0;
				tp[1] = a1;
				tp[2] = a2;
				tp[3] = a3;
				tp += tstride;
			}
		}

		void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy)
		{
			float* op = (float*)ostart;
			int xc = ox + ow, tstride = smapy * Channels;

			while (ox < xc)
			{
				float* tp = (float*)tstart + ox * tstride;
				float* tpe = tp + tstride - 4 * Vector<float>.Count;
				float* mp = (float*)pmapy;

				Vector<float> av0 = Vector<float>.Zero;

				while (tp <= tpe)
				{
					var tv0 = Unsafe.Read<Vector<float>>(tp);
					var tv1 = Unsafe.Read<Vector<float>>(tp + Vector<float>.Count);
					var tv2 = Unsafe.Read<Vector<float>>(tp + 2 * Vector<float>.Count);
					var tv3 = Unsafe.Read<Vector<float>>(tp + 3 * Vector<float>.Count);

					var mv0 = Unsafe.Read<Vector<float>>(mp);
					var mv1 = Unsafe.Read<Vector<float>>(mp + Vector<float>.Count);
					var mv2 = Unsafe.Read<Vector<float>>(mp + 2 * Vector<float>.Count);
					var mv3 = Unsafe.Read<Vector<float>>(mp + 3 * Vector<float>.Count);

					av0 += tv0 * mv0;
					av0 += tv1 * mv1;
					av0 += tv2 * mv2;
					av0 += tv3 * mv3;

					tp += 4 * Vector<float>.Count;
					mp += 4 * Vector<float>.Count;
				}

				float a0 = av0[0];
				float a1 = av0[1];
				float a2 = av0[2];
				float a3 = av0[3];

				if (Vector<float>.Count == 8)
				{
					a0 += av0[4];
					a1 += av0[5];
					a2 += av0[6];
					a3 += av0[7];
				}

				tpe += 4 * Vector<float>.Count;
				while (tp < tpe)
				{
					a0 += tp[0] * mp[0];
					a1 += tp[1] * mp[1];
					a2 += tp[2] * mp[2];
					a3 += tp[3] * mp[3];

					tp += Channels;
					mp += Channels;
				}

				op[0] = a0;
				op[1] = a1;
				op[2] = a2;
				op[3] = a3;
				op += Channels;
				ox++;
			}
		}

		void IConvolver.SharpenLine(byte* cstart, byte* bstart, byte* ostart, int ox, int ow, int amt, int thresh) => throw new NotImplementedException();
	}

	unsafe internal class Convolver3ChanFloat : IConvolver
	{
		private const int Channels = 3;
		private static readonly Vector<int> mask00;
		private static readonly Vector<int> mask10;
		private static readonly Vector<int> mask20;
		private static readonly Vector<int> mask01;
		private static readonly Vector<int> mask11;
		private static readonly Vector<int> mask21;

		static Convolver3ChanFloat()
		{
			var arr = new int[Vector<int>.Count];
			for (int i = 0; i < Vector<int>.Count; i++)
				arr[i] = i % Channels == 0 ? -1 : 0;
			mask00 = new Vector<int>(arr);

			for (int i = 0; i < Vector<int>.Count; i++)
				arr[i] = i % Channels == 1 ? -1 : 0;
			mask10 = new Vector<int>(arr);

			for (int i = 0; i < Vector<int>.Count; i++)
				arr[i] = i % Channels == 2 ? -1 : 0;
			mask20 = new Vector<int>(arr);

			for (int i = 0; i < Vector<int>.Count; i++)
				arr[i] = i % Channels == Vector<int>.Count % Channels ? 0 : -1;
			mask01 = new Vector<int>(arr);

			for (int i = 0; i < Vector<int>.Count; i++)
				arr[i] = i % Channels == (Vector<int>.Count + 1) % Channels ? 0 : -1;
			mask11 = new Vector<int>(arr);

			for (int i = 0; i < Vector<int>.Count; i++)
				arr[i] = i % Channels == (Vector<int>.Count + 2) % Channels ? 0 : -1;
			mask21 = new Vector<int>(arr);
		}

		void IConvolver.ConvolveSourceLine(byte* istart, byte* tstart, int cb, byte* mapxstart, int smapx, int smapy)
		{
			float* pmapx = (float*)mapxstart;
			float* tp = (float*)tstart;
			float* tpe = (float*)(tstart + cb);
			int tstride = smapy * Channels;

			Vector<float> m0 = Vector<float>.One;
			Vector<int> m00 = mask00, m10 = mask10, m20 = mask20, m01 = mask01, m11 = mask11, m21 = mask21;

			while (tp < tpe)
			{
				int ix = *(int*)pmapx++;
				float* ip = (float*)istart + ix * Channels;
				float* ipe = ip + smapx * Channels - 3 * Vector<float>.Count;
				float* mp = pmapx;
				pmapx += smapx * Channels;

				Vector<float> av0 = Vector<float>.Zero, av1 = av0, av2 = av0;

				while (ip <= ipe)
				{
					var iv0 = Unsafe.Read<Vector<float>>(ip);
					var iv1 = Unsafe.Read<Vector<float>>(ip + Vector<float>.Count);
					var iv2 = Unsafe.Read<Vector<float>>(ip + 2 * Vector<float>.Count);

					var mv0 = Unsafe.Read<Vector<float>>(mp);
					var mv1 = Unsafe.Read<Vector<float>>(mp + Vector<float>.Count);
					var mv2 = Unsafe.Read<Vector<float>>(mp + 2 * Vector<float>.Count);

					av0 += iv0 * mv0;
					av1 += iv1 * mv1;
					av2 += iv2 * mv2;

					ip += 3 * Vector<float>.Count;
					mp += 3 * Vector<float>.Count;
				}

				var at0 = Vector.ConditionalSelect(m00, av0, av1);
				var at1 = Vector.ConditionalSelect(m10, av0, av1);
				var at2 = Vector.ConditionalSelect(m20, av0, av1);

				at0 = Vector.ConditionalSelect(m01, at0, av2);
				at1 = Vector.ConditionalSelect(m11, at1, av2);
				at2 = Vector.ConditionalSelect(m21, at2, av2);

				float a0 = Vector.Dot(at0, m0);
				float a1 = Vector.Dot(at1, m0);
				float a2 = Vector.Dot(at2, m0);

				ipe += 3 * Vector<float>.Count;
				while (ip < ipe)
				{
					a0 += ip[0] * mp[0];
					a1 += ip[1] * mp[1];
					a2 += ip[2] * mp[2];

					ip += Channels;
					mp += Channels;
				}

				tp[0] = a0;
				tp[1] = a1;
				tp[2] = a2;
				tp += tstride;
			}
		}

		void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy)
		{
			float* op = (float*)ostart;
			int xc = ox + ow, tstride = smapy * Channels;

			Vector<float> m0 = Vector<float>.One;
			Vector<int> m00 = mask00, m10 = mask10, m20 = mask20, m01 = mask01, m11 = mask11, m21 = mask21;

			while (ox < xc)
			{
				float* tp = (float*)tstart + ox * tstride;
				float* tpe = tp + tstride - 3 * Vector<float>.Count;
				float* mp = (float*)pmapy;

				Vector<float> av0 = Vector<float>.Zero, av1 = av0, av2 = av0;

				while (tp <= tpe)
				{
					var tv0 = Unsafe.Read<Vector<float>>(tp);
					var tv1 = Unsafe.Read<Vector<float>>(tp + Vector<float>.Count);
					var tv2 = Unsafe.Read<Vector<float>>(tp + 2 * Vector<float>.Count);

					var mv0 = Unsafe.Read<Vector<float>>(mp);
					var mv1 = Unsafe.Read<Vector<float>>(mp + Vector<float>.Count);
					var mv2 = Unsafe.Read<Vector<float>>(mp + 2 * Vector<float>.Count);

					av0 += tv0 * mv0;
					av1 += tv1 * mv1;
					av2 += tv2 * mv2;

					tp += 3 * Vector<float>.Count;
					mp += 3 * Vector<float>.Count;
				}

				var at0 = Vector.ConditionalSelect(m00, av0, av1);
				var at1 = Vector.ConditionalSelect(m10, av0, av1);
				var at2 = Vector.ConditionalSelect(m20, av0, av1);

				at0 = Vector.ConditionalSelect(m01, at0, av2);
				at1 = Vector.ConditionalSelect(m11, at1, av2);
				at2 = Vector.ConditionalSelect(m21, at2, av2);

				float a0 = Vector.Dot(at0, m0);
				float a1 = Vector.Dot(at1, m0);
				float a2 = Vector.Dot(at2, m0);

				tpe += 3 * Vector<float>.Count;
				while (tp < tpe)
				{
					a0 += tp[0] * mp[0];
					a1 += tp[1] * mp[1];
					a2 += tp[2] * mp[2];

					tp += Channels;
					mp += Channels;
				}

				op[0] = a0;
				op[1] = a1;
				op[2] = a2;
				op += Channels;
				ox++;
			}
		}

		void IConvolver.SharpenLine(byte* cstart, byte* bstart, byte* ostart, int ox, int ow, int amt, int thresh) => throw new NotImplementedException();
	}

	unsafe internal class Convolver2ChanFloat : IConvolver
	{
		private const int Channels = 2;
		private static readonly Vector<float> mask0;
		private static readonly Vector<float> mask1;

		static Convolver2ChanFloat()
		{
			var arr = new float[Vector<float>.Count];
			for (int i = 0; i < Vector<float>.Count; i++)
				arr[i] = i % Channels == 0 ? 1f : 0f;
			mask0 = new Vector<float>(arr);

			for (int i = 0; i < Vector<float>.Count; i++)
				arr[i] = i % Channels == 1 ? 1f : 0f;
			mask1 = new Vector<float>(arr);
		}

		void IConvolver.ConvolveSourceLine(byte* istart, byte* tstart, int cb, byte* mapxstart, int smapx, int smapy)
		{
			float* pmapx = (float*)mapxstart;
			float* tp = (float*)tstart;
			float* tpe = (float*)(tstart + cb);
			int tstride = smapy * Channels;

			Vector<float> m0 = mask0, m1 = mask1;

			while (tp < tpe)
			{
				int ix = *(int*)pmapx++;
				float* ip = (float*)istart + ix * Channels;
				float* ipe = ip + smapx * Channels - 2 * Vector<float>.Count;
				float* mp = pmapx;
				pmapx += smapx * Channels;

				Vector<float> av0 = Vector<float>.Zero;

				while (ip <= ipe)
				{
					var iv0 = Unsafe.Read<Vector<float>>(ip);
					var iv1 = Unsafe.Read<Vector<float>>(ip + Vector<float>.Count);

					var mv0 = Unsafe.Read<Vector<float>>(mp);
					var mv1 = Unsafe.Read<Vector<float>>(mp + Vector<float>.Count);

					av0 += iv0 * mv0;
					av0 += iv1 * mv1;

					ip += 2 * Vector<float>.Count;
					mp += 2 * Vector<float>.Count;
				}

				float a0 = Vector.Dot(av0, m0);
				float a1 = Vector.Dot(av0, m1);

				ipe += 2 * Vector<float>.Count;
				while (ip < ipe)
				{
					a0 += ip[0] * mp[0];
					a1 += ip[1] * mp[1];

					ip += Channels;
					mp += Channels;
				}

				tp[0] = a0;
				tp[1] = a1;
				tp += tstride;
			}
		}

		void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy)
		{
			float* op = (float*)ostart;
			int xc = ox + ow, tstride = smapy * Channels;

			Vector<float> m0 = mask0, m1 = mask1;

			while (ox < xc)
			{
				float* tp = (float*)tstart + ox * tstride;
				float* tpe = tp + tstride - 2 * Vector<float>.Count;
				float* mp = (float*)pmapy;

				Vector<float> av0 = Vector<float>.Zero;

				while (tp <= tpe)
				{
					var tv0 = Unsafe.Read<Vector<float>>(tp);
					var tv1 = Unsafe.Read<Vector<float>>(tp + Vector<float>.Count);

					var mv0 = Unsafe.Read<Vector<float>>(mp);
					var mv1 = Unsafe.Read<Vector<float>>(mp + Vector<float>.Count);

					av0 += tv0 * mv0;
					av0 += tv1 * mv1;

					tp += 2 * Vector<float>.Count;
					mp += 2 * Vector<float>.Count;
				}

				float a0 = Vector.Dot(av0, m0);
				float a1 = Vector.Dot(av0, m1);

				tpe += 2 * Vector<float>.Count;
				while (tp < tpe)
				{
					a0 += tp[0] * mp[0];
					a1 += tp[1] * mp[1];

					tp += Channels;
					mp += Channels;
				}

				op[0] = a0;
				op[1] = a1;
				op += Channels;
				ox++;
			}
		}

		void IConvolver.SharpenLine(byte* cstart, byte* bstart, byte* ostart, int ox, int ow, int amt, int thresh) => throw new NotImplementedException();
	}

	unsafe internal class Convolver1ChanFloat : IConvolver
	{
		private const int Channels = 1;

		void IConvolver.ConvolveSourceLine(byte* istart, byte* tstart, int cb, byte* mapxstart, int smapx, int smapy)
		{
			float* pmapx = (float*)mapxstart;
			float* tp = (float*)tstart;
			float* tpe = (float*)(tstart + cb);
			int tstride = smapy * Channels;

			Vector<float> m0 = Vector<float>.One;

			while (tp < tpe)
			{
				int ix = *(int*)pmapx++;
				float* ip = (float*)istart + ix * Channels;
				float* ipe = ip + smapx * Channels - Vector<float>.Count;
				float* mp = pmapx;
				pmapx += smapx * Channels;

				Vector<float> av0 = Vector<float>.Zero;

				while (ip <= ipe)
				{
					var iv0 = Unsafe.Read<Vector<float>>(ip);

					var mv0 = Unsafe.Read<Vector<float>>(mp);

					av0 += iv0 * mv0;

					ip += Vector<float>.Count;
					mp += Vector<float>.Count;
				}

				float a0 = Vector.Dot(av0, m0);

				ipe += Vector<float>.Count;
				while (ip < ipe)
				{
					a0 += ip[0] * mp[0];

					ip += Channels;
					mp += Channels;
				}

				tp[0] = a0;
				tp += tstride;
			}
		}

		void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy)
		{
			float* op = (float*)ostart;
			int xc = ox + ow, tstride = smapy * Channels;

			Vector<float> m0 = Vector<float>.One;

			while (ox < xc)
			{
				float* tp = (float*)tstart + ox * tstride;
				float* tpe = tp + tstride - Vector<float>.Count;
				float* mp = (float*)pmapy;

				Vector<float> av0 = Vector<float>.Zero;

				while (tp <= tpe)
				{
					var tv0 = Unsafe.Read<Vector<float>>(tp);

					var mv0 = Unsafe.Read<Vector<float>>(mp);

					av0 += tv0 * mv0;

					tp += Vector<float>.Count;
					mp += Vector<float>.Count;
				}

				float a0 = Vector.Dot(av0, m0);

				tpe += Vector<float>.Count;
				while (tp < tpe)
				{
					a0 += tp[0] * mp[0];

					tp += Channels;
					mp += Channels;
				}

				op[0] = a0;
				op += Channels;
				ox++;
			}
		}

		void IConvolver.SharpenLine(byte* cstart, byte* bstart, byte* ostart, int ox, int ow, int amt, int thresh) => throw new NotImplementedException();
	}
}
