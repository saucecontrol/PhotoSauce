<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#
procDef[] ta = {
	new procDef {
		name = "4Chan",
		channels = 4,
		colors = 4,
		xUnroll = 2,
		yUnroll = 2
	},
	new procDef {
		name = "3Chan",
		channels = 3,
		colors = 3,
		xUnroll = 3,
		yUnroll = 0
	},
	new procDef {
		name = "1Chan",
		channels = 1,
		colors = 1,
		xUnroll = 2,
		yUnroll = 2
	}
};
#>
//------------------------------------------------------------------------------
//	<auto-generated>
//		This code was generated from a template.
//		Manual changes to this file will be overwritten if the code is regenerated.
//	</auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Numerics;
using System.Runtime.CompilerServices;

using VectorF = System.Numerics.Vector<float>;

namespace PhotoSauce.MagicScaler.Transforms
{
<#
foreach (var t in ta) {
	if (t != ta[0]) WriteLine(null);
#>
	internal sealed partial class Convolver<#= t.name #>Vector : IConvolver
	{
		private const int channels = <#= t.channels #>;
		private const int vector4Count = 4;

		public static readonly Convolver<#= t.name #>Vector Instance = new();

		private Convolver<#= t.name #>Vector() { }

		int IConvolver.Channels => channels;
		int IConvolver.MapChannels => channels;

		unsafe void IConvolver.ConvolveSourceLine(byte* istart, byte* tstart, nint cb, byte* mapxstart, int smapx, int smapy)
		{
			float* tp = (float*)tstart, tpe = (float*)(tstart + cb);
			uint* pmapx = (uint*)mapxstart;
			nint kstride = smapx * channels;
			nint tstride = smapy * <#= t.channels == 3 ? "4" /* 3Chan to 3XChan x-over */ : "channels" #>;
			nint vcnt = kstride / vector4Count;

<#
if (t.channels == 1) {
#>
			var m4 = Vector4.One;
			var mF = VectorF.One;
<#
} else {
#>
			float* buff = stackalloc float[VectorF.Count];
<#
}
#>

			while (tp < tpe)
			{
				nint lcnt = vcnt;
				nuint ix = *pmapx++;

				float* ip = (float*)istart + ix * channels<#= t.channels != 4 ? ", ipe = ip + kstride" : "" #>;
				float* mp = (float*)(mapxstart + *pmapx++);

				<#= t.channels == 1 ? "float a0" : "Vector4 av0" #><# for (int i = 1; t.channels == 3 && i < t.colors || t.channels == 4 && i < 2; i++) { #>, av<#= i #><# } #>;
				if (VectorF.Count == 8 && lcnt >= <#= (t.channels == 3 ? 6 : 2) * 2 #>)
				{
<#
for (int i = 0; i < (t.channels == 3 ? 3 : 2); i++) {
#>
					var ax<#= i #> = VectorF.Zero;
<#
}

for (int unroll = t.xUnroll; unroll > 0; unroll -= (t.channels == 3 ? 3 : 2)) {
#>

					do
					{
						lcnt -= <#= unroll * 2 #>;

<#
	for (int i = 0; i < unroll; i++) {
#>
						var iv<#= i #> = Unsafe.ReadUnaligned<VectorF>(ip<#= i != 0 ? $" + VectorF.Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
	}
#>
						ip += VectorF.Count<#= unroll > 1 ? $" * {unroll}" : "" #>;

<#
	for (int i = 0; i < unroll; i++) {
#>
						ax<#= t.channels == 3 ? i : i % 2 #> += iv<#= i #> * Unsafe.ReadUnaligned<VectorF>(mp<#= i != 0 ? $" + VectorF.Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
	}
#>
						mp += VectorF.Count<#= unroll > 1 ? $" * {unroll}" : "" #>;

					} while (lcnt >= <#= unroll * 2 #>);

<#
	if (unroll == t.xUnroll && t.channels != 3) {
#>
					ax0 += ax1;

					if (lcnt >= 2)
					{
						lcnt -= 2;

						var iv0 = Unsafe.ReadUnaligned<VectorF>(ip);
						ip += VectorF.Count;

						ax0 += iv0 * Unsafe.ReadUnaligned<VectorF>(mp);
						mp += VectorF.Count;
					}

<#
	}
}

if (t.channels == 3) {
#>
					Unsafe.WriteUnaligned(buff, ax0);
					av0 = Unsafe.ReadUnaligned<Vector4>(buff);
					av1 = Unsafe.ReadUnaligned<Vector4>(buff + vector4Count);

					Unsafe.WriteUnaligned(buff, ax1);
					av2 = Unsafe.ReadUnaligned<Vector4>(buff);
					av0 += Unsafe.ReadUnaligned<Vector4>(buff + vector4Count);

					Unsafe.WriteUnaligned(buff, ax2);
					av1 += Unsafe.ReadUnaligned<Vector4>(buff);
					av2 += Unsafe.ReadUnaligned<Vector4>(buff + vector4Count);
<#
} else if (t.channels == 1) {
#>
					a0 = Vector.Dot(ax0, mF);
<#
} else {
#>
					Unsafe.WriteUnaligned(buff, ax0);
					av0 = Unsafe.ReadUnaligned<Vector4>(buff) + Unsafe.ReadUnaligned<Vector4>(buff + vector4Count);
<#
}
#>
				}
				else
				{
<#
if (t.channels == 1) {
#>
					var av0 = Vector4.Zero;
					var av1 = Vector4.Zero;
<#
} else {
#>
					av0<# for (int i = 1; i < (t.channels == 3 ? 3 : 2 ); i++) { #> = av<#= i #><# } #> = Vector4.Zero;
<#
}
for (int unroll = t.xUnroll; t.channels != 3 && unroll > 0; unroll -= 2) {
#>

					while (lcnt >= <#= unroll #>)
					{
						lcnt -= <#= unroll #>;

<#
	for (int i = 0; i < unroll; i++) {
#>
						var iv<#= i #> = Unsafe.ReadUnaligned<Vector4>(ip<#= i != 0 ? $" + vector4Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
	}
#>
						ip += vector4Count<#= unroll > 1 ? $" * {unroll}" : "" #>;

<#
	for (int i = 0; i < unroll; i++) {
#>
						av<#= t.channels == 3 ? i : i % 2 #> += iv<#= i #> * Unsafe.ReadUnaligned<Vector4>(mp<#= i != 0 ? $" + vector4Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
	}
#>
						mp += vector4Count<#= unroll > 1 ? $" * {unroll}" : "" #>;
					}
<#
}
if (t.channels == 4) {
#>

					av0 += av1;
<#
}
if (t.channels != 1) {
#>
				}
<#
}
WriteLine(null);
int cxunroll = t.channels == 3 ? 3 : 1;
if (t.channels == 3) {
#>
				while (lcnt != 0)
				{
					lcnt -= <#= cxunroll #>;

<#
} else {
	if (t.channels == 1) {
		PushIndent("\t");
#>
				av0 += av1;

<#
	}
#>
				if (lcnt != 0)
				{
<#
}
for (int i = 0; i < cxunroll; i++) {
#>
					var iv<#= i #> = Unsafe.ReadUnaligned<Vector4>(ip<#= i != 0 ? $" + vector4Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
}
if (t.channels != 4) {
#>
					ip += vector4Count<#= cxunroll > 1 ? $" * {cxunroll}" : "" #>;
<#
}
WriteLine(null);
for (int i = 0; i < cxunroll; i++) {
#>
					av<#= t.channels == 3 ? i : 0 #> += iv<#= i #> * Unsafe.ReadUnaligned<Vector4>(mp<#= i != 0 ? $" + vector4Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
}
if (t.channels != 4) {
#>
					mp += vector4Count<#= cxunroll > 1 ? $" * {cxunroll}" : "" #>;
<#
}
#>
				}
<#
if (t.channels == 1) {
	PopIndent();
#>

					a0 = Vector4.Dot(av0, m4);
				}
<#
} else if (t.channels == 3) {
#>

				float a0, a1, a2;
				if (vcnt == 0)
				{
					a0 = a1 = a2 = 0f;
				}
				else
				{
					a0 = av0.X + av0.W + av1.Z + av2.Y;
					a1 = av0.Y + av1.X + av1.W + av2.Z;
					a2 = av0.Z + av1.Y + av2.X + av2.W;
				}
<#
}

if (t.channels != 4) {
#>

				while (ip < ipe)
				{
<#
for (int i = 0; i < t.colors; i++) {
#>
					a<#= i #> += ip[<#= i #>] * mp[<#= i #>];
<#
}
#>

					ip += channels;
					mp += channels;
				}

<#
	for (int j = 0; j < t.colors; j++) {
#>
				tp[<#= j #>] = a<#= j #>;
<#
	}
} else {
#>

				Unsafe.WriteUnaligned(tp, av0);
<#
}
#>
				tp += tstride;
			}
		}

<#
if (t.yUnroll > 0) {
#>
		unsafe void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy)
		{
			float* op = (float*)ostart;
			nint tstride = smapy * channels;
			nint vcnt = tstride / vector4Count;

<#
if (t.channels == 1) {
#>
			var m4 = Vector4.One;
			var mF = VectorF.One;
<#
} else {
#>
			float* buff = stackalloc float[VectorF.Count];
<#
}
#>

			for (nint nox = ox, xc = nox + ow; nox < xc; nox++)
			{
				nint lcnt = vcnt;

				float* tp = (float*)tstart + nox * tstride<#= t.channels != 4 ? ", tpe = tp + tstride" : "" #>;
				float* mp = (float*)pmapy;

				<#= t.channels == 1 ? "float a0" : "Vector4 av0" #><# for (int i = 1; t.channels == 3 && i < t.colors || t.channels == 4 && i < 2; i++) { #>, av<#= i #><# } #>;
				if (VectorF.Count == 8 && lcnt >= <#= (t.channels == 3 ? 3 : 2) * 2 #>)
				{
<#
for (int i = 0; i < (t.channels == 3 ? 3 : 2); i++) {
#>
					var ax<#= i #> = VectorF.Zero;
<#
}

for (int unroll = t.yUnroll; unroll > 0; unroll -= (t.channels == 3 ? 3 : 2)) {
#>

					do
					{
						lcnt -= <#= unroll * 2 #>;

<#
	for (int i = 0; i < unroll; i++) {
#>
						var iv<#= i #> = Unsafe.ReadUnaligned<VectorF>(tp<#= i != 0 ? $" + VectorF.Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
	}
#>
						tp += VectorF.Count<#= unroll > 1 ? $" * {unroll}" : "" #>;

<#
	for (int i = 0; i < unroll; i++) {
#>
						ax<#= t.channels == 3 ? i : i % 2 #> += iv<#= i #> * Unsafe.ReadUnaligned<VectorF>(mp<#= i != 0 ? $" + VectorF.Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
	}
#>
						mp += VectorF.Count<#= unroll > 1 ? $" * {unroll}" : "" #>;

					} while (lcnt >= <#= unroll * 2 #>);

<#
	if (unroll == t.xUnroll && t.channels != 3) {
#>
					ax0 += ax1;

					if (lcnt >= 2)
					{
						lcnt -= 2;

						var iv0 = Unsafe.ReadUnaligned<VectorF>(tp);
						tp += VectorF.Count;

						ax0 += iv0 * Unsafe.ReadUnaligned<VectorF>(mp);
						mp += VectorF.Count;
					}

<#
	}
}

if (t.channels == 1) {
#>
					a0 = Vector.Dot(ax0, mF);
<#
} else {
#>
					Unsafe.WriteUnaligned(buff, ax0);
					av0 = Unsafe.ReadUnaligned<Vector4>(buff) + Unsafe.ReadUnaligned<Vector4>(buff + vector4Count);
<#
}
#>
				}
				else
				{
<#
if (t.channels == 1) {
#>
					var av0 = Vector4.Zero;
					var av1 = Vector4.Zero;
<#
} else {
#>
					av0<# for (int i = 1; i < (t.channels == 3 ? 3 : 2 ); i++) { #> = av<#= i #><# } #> = Vector4.Zero;
<#
}
for (int unroll = t.yUnroll; t.channels != 3 && unroll > 0; unroll -= 2) {
#>

					while (lcnt >= <#= unroll #>)
					{
						lcnt -= <#= unroll #>;

<#
	for (int i = 0; i < unroll; i++) {
#>
						var iv<#= i #> = Unsafe.ReadUnaligned<Vector4>(tp<#= i != 0 ? $" + vector4Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
	}
#>
						tp += vector4Count<#= unroll > 1 ? $" * {unroll}" : "" #>;

<#
	for (int i = 0; i < unroll; i++) {
#>
						av<#= t.channels == 3 ? i : i % 2 #> += iv<#= i #> * Unsafe.ReadUnaligned<Vector4>(mp<#= i != 0 ? $" + vector4Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
	}
#>
						mp += vector4Count<#= unroll > 1 ? $" * {unroll}" : "" #>;
					}

<#
}
if (t.channels == 4) {
#>
					av0 += av1;
<#
}
if (t.channels != 1) {
#>
				}
<#
}
	if (t.channels == 1) {
		PushIndent("\t");
#>
				av0 += av1;
<#
	}
#>

				if (lcnt != 0)
				{
<#
int cyunroll = t.channels == 3 ? 3 : 1;
for (int i = 0; i < cyunroll; i++) {
#>
					var iv<#= i #> = Unsafe.ReadUnaligned<Vector4>(tp<#= i != 0 ? $" + vector4Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
}
if (t.channels != 4) {
#>
					tp += vector4Count<#= cyunroll > 1 ? $" * {cyunroll}" : "" #>;
<#
}
WriteLine(null);
for (int i = 0; i < cyunroll; i++) {
#>
					av<#= t.channels == 3 ? i : 0 #> += iv<#= i #> * Unsafe.ReadUnaligned<Vector4>(mp<#= i != 0 ? $" + vector4Count{(i > 1 ? $" * {i}" : "")}" : "" #>);
<#
}
if (t.channels != 4) {
#>
					mp += vector4Count<#= cyunroll > 1 ? $" * {cyunroll}" : "" #>;
<#
}
#>
				}
<#
if (t.channels == 1) {
	PopIndent();
#>

					a0 = Vector4.Dot(av0, m4);
				}
<#
}

if (t.channels != 4) {
#>

				while (tp < tpe)
				{
<#
for (int i = 0; i < t.colors; i++) {
#>
					a<#= i #> += tp[<#= i #>] * mp[<#= i #>];
<#
}
#>

					tp += channels;
					mp += channels;
				}

<#
	for (int j = 0; j < t.colors; j++) {
#>
				op[<#= j #>] = a<#= j #>;
<#
	}
} else {
#>

				Unsafe.WriteUnaligned(op, av0);
<#
}
#>
				op += channels;
			}
		}
<#
} else {
#>
		unsafe void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy) => throw new NotImplementedException();
<#
}
#>

		public override string ToString() => nameof(Convolver<#= t.name #>Vector);
	}
<#
}
#>
}
<#+
class procDef
{
	public string name;
	public int channels;
	public int colors;
	public int xUnroll;
	public int yUnroll;
}
#>