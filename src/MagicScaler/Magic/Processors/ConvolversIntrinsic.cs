//------------------------------------------------------------------------------
//	<auto-generated>
//		This code was generated from a template.
//		Manual changes to this file will be overwritten if the code is regenerated.
//	</auto-generated>
//------------------------------------------------------------------------------

#if HWINTRINSICS
using System;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;
using System.Runtime.CompilerServices;

using VectorAvx = System.Runtime.Intrinsics.Vector256<float>;
using VectorSse = System.Runtime.Intrinsics.Vector128<float>;

namespace PhotoSauce.MagicScaler.Transforms
{
	internal sealed partial class Convolver4ChanIntrinsic : IConvolver
	{
		private const int channels = 4;

		public static readonly Convolver4ChanIntrinsic Instance = new();

		private Convolver4ChanIntrinsic() { }

		int IConvolver.Channels => channels;
		int IConvolver.MapChannels => channels;

		[MethodImpl(MethodImplOptions.AggressiveOptimization)]
		unsafe void IConvolver.ConvolveSourceLine(byte* istart, byte* tstart, nint cb, byte* mapxstart, int smapx, int smapy)
		{
			float* tp = (float*)tstart, tpe = (float*)(tstart + cb);
			uint* pmapx = (uint*)mapxstart;
			nint kstride = smapx * channels;
			nint tstride = smapy * channels;
			nint vcnt = kstride / VectorSse.Count;

			while (tp < tpe)
			{
				nint lcnt = vcnt;
				nuint ix = *pmapx++;

				float* ip = (float*)istart + ix * channels;
				float* mp = (float*)(mapxstart + *pmapx++);

				VectorSse av0, av1;
				if (Avx.IsSupported && lcnt >= 4)
				{
					var ax0 = VectorAvx.Zero;
					var ax1 = VectorAvx.Zero;

					do
					{
						lcnt -= 4;

						var iv0 = Avx.LoadVector256(ip);
						var iv1 = Avx.LoadVector256(ip + VectorAvx.Count);
						ip += VectorAvx.Count * 2;

						ax0 = HWIntrinsics.MultiplyAdd(ax0, iv0, mp);
						ax1 = HWIntrinsics.MultiplyAdd(ax1, iv1, mp + VectorAvx.Count);
						mp += VectorAvx.Count * 2;

					} while (lcnt >= 4);

					ax0 = Avx.Add(ax0, ax1);

					if (lcnt >= 2)
					{
						lcnt -= 2;

						var iv0 = Avx.LoadVector256(ip);
						ip += VectorAvx.Count;

						ax0 = HWIntrinsics.MultiplyAdd(ax0, iv0, mp);
						mp += VectorAvx.Count;
					}

					av0 = Sse.Add(ax0.GetLower(), ax0.GetUpper());
				}
				else
				{
					av0 = av1 = VectorSse.Zero;

					while (lcnt >= 2)
					{
						lcnt -= 2;

						var iv0 = Sse.LoadVector128(ip);
						var iv1 = Sse.LoadVector128(ip + VectorSse.Count);
						ip += VectorSse.Count * 2;

						av0 = HWIntrinsics.MultiplyAdd(av0, iv0, mp);
						av1 = HWIntrinsics.MultiplyAdd(av1, iv1, mp + VectorSse.Count);
						mp += VectorSse.Count * 2;
					}

					av0 = Sse.Add(av0, av1);
				}

				if (lcnt != 0)
				{
					var iv0 = Sse.LoadVector128(ip);

					av0 = HWIntrinsics.MultiplyAdd(av0, iv0, mp);
				}

				Sse.Store(tp, av0);
				tp += tstride;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveOptimization)]
		unsafe void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy)
		{
			float* op = (float*)ostart;
			nint tstride = smapy * channels;
			nint vcnt = tstride / VectorSse.Count;

			for (nint nox = ox, xc = nox + ow; nox < xc; nox++)
			{
				nint lcnt = vcnt;

				float* tp = (float*)tstart + nox * tstride;
				float* mp = (float*)pmapy;

				VectorSse av0, av1;
				if (Avx.IsSupported && lcnt >= 4)
				{
					var ax0 = VectorAvx.Zero;
					var ax1 = VectorAvx.Zero;

					do
					{
						lcnt -= 4;

						var iv0 = Avx.LoadVector256(tp);
						var iv1 = Avx.LoadVector256(tp + VectorAvx.Count);
						tp += VectorAvx.Count * 2;

						ax0 = HWIntrinsics.MultiplyAdd(ax0, iv0, mp);
						ax1 = HWIntrinsics.MultiplyAdd(ax1, iv1, mp + VectorAvx.Count);
						mp += VectorAvx.Count * 2;

					} while (lcnt >= 4);

					ax0 = Avx.Add(ax0, ax1);

					if (lcnt >= 2)
					{
						lcnt -= 2;

						var iv0 = Avx.LoadVector256(tp);
						tp += VectorAvx.Count;

						ax0 = HWIntrinsics.MultiplyAdd(ax0, iv0, mp);
						mp += VectorAvx.Count;
					}

					av0 = Sse.Add(ax0.GetLower(), ax0.GetUpper());
				}
				else
				{
					av0 = av1 = VectorSse.Zero;

					while (lcnt >= 2)
					{
						lcnt -= 2;

						var iv0 = Sse.LoadVector128(tp);
						var iv1 = Sse.LoadVector128(tp + VectorSse.Count);
						tp += VectorSse.Count * 2;

						av0 = HWIntrinsics.MultiplyAdd(av0, iv0, mp);
						av1 = HWIntrinsics.MultiplyAdd(av1, iv1, mp + VectorSse.Count);
						mp += VectorSse.Count * 2;
					}

					av0 = Sse.Add(av0, av1);
				}

				if (lcnt != 0)
				{
					var iv0 = Sse.LoadVector128(tp);

					av0 = HWIntrinsics.MultiplyAdd(av0, iv0, mp);
				}

				Sse.Store(op, av0);
				op += channels;
			}
		}

		public override string ToString() => nameof(Convolver4ChanIntrinsic);
	}

	internal sealed partial class Convolver4ChanVector : IVectorConvolver
	{
		IConvolver IVectorConvolver.IntrinsicImpl => Sse.IsSupported ? Convolver4ChanIntrinsic.Instance : (IConvolver)this;
	}

	internal sealed partial class Convolver3ChanIntrinsic : IConvolver
	{
		private const int channels = 3;

		public static readonly Convolver3ChanIntrinsic Instance = new();

		private Convolver3ChanIntrinsic() { }

		int IConvolver.Channels => channels;
		int IConvolver.MapChannels => channels;

		[MethodImpl(MethodImplOptions.AggressiveOptimization)]
		unsafe void IConvolver.ConvolveSourceLine(byte* istart, byte* tstart, nint cb, byte* mapxstart, int smapx, int smapy)
		{
			float* tp = (float*)tstart, tpe = (float*)(tstart + cb);
			uint* pmapx = (uint*)mapxstart;
			nint kstride = smapx * channels;
			nint tstride = smapy * 4;
			nint vcnt = kstride / VectorSse.Count;

			while (tp < tpe)
			{
				nint lcnt = vcnt;
				nuint ix = *pmapx++;

				float* ip = (float*)istart + ix * channels;
				float* mp = (float*)(mapxstart + *pmapx++);

				VectorSse av0, av1, av2;
				if (Avx.IsSupported && lcnt >= 6)
				{
					var ax0 = VectorAvx.Zero;
					var ax1 = VectorAvx.Zero;
					var ax2 = VectorAvx.Zero;

					do
					{
						lcnt -= 6;

						var iv0 = Avx.LoadVector256(ip);
						var iv1 = Avx.LoadVector256(ip + VectorAvx.Count);
						var iv2 = Avx.LoadVector256(ip + VectorAvx.Count * 2);
						ip += VectorAvx.Count * 3;

						ax0 = HWIntrinsics.MultiplyAdd(ax0, iv0, mp);
						ax1 = HWIntrinsics.MultiplyAdd(ax1, iv1, mp + VectorAvx.Count);
						ax2 = HWIntrinsics.MultiplyAdd(ax2, iv2, mp + VectorAvx.Count * 2);
						mp += VectorAvx.Count * 3;

					} while (lcnt >= 6);

					av0 = Sse.Add(ax0.GetLower(), ax1.GetUpper());
					av1 = Sse.Add(ax0.GetUpper(), ax2.GetLower());
					av2 = Sse.Add(ax1.GetLower(), ax2.GetUpper());
				}
				else
				{
					av0 = av1 = av2 = VectorSse.Zero;
				}

				while (lcnt != 0)
				{
					lcnt -= 3;

					var iv0 = Sse.LoadVector128(ip);
					var iv1 = Sse.LoadVector128(ip + VectorSse.Count);
					var iv2 = Sse.LoadVector128(ip + VectorSse.Count * 2);
					ip += VectorSse.Count * 3;

					av0 = HWIntrinsics.MultiplyAdd(av0, iv0, mp);
					av1 = HWIntrinsics.MultiplyAdd(av1, iv1, mp + VectorSse.Count);
					av2 = HWIntrinsics.MultiplyAdd(av2, iv2, mp + VectorSse.Count * 2);
					mp += VectorSse.Count * 3;
				}

				var avs = Sse.Add(Sse.Add(
					Sse.Shuffle(av0, av0, 0b_00_10_01_11),
					Sse.Shuffle(av1, av1, 0b_00_01_11_10)),
					Sse.Shuffle(av2, av2, 0b_00_11_10_01)
				);

				av0 = Sse.MoveLowToHigh(Sse.UnpackLow(av0, av1), av2);
				av0 = Sse.Add(av0, avs);

				Sse.Store(tp, av0);
				tp += tstride;
			}
		}

		unsafe void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy) => throw new NotImplementedException();

		public override string ToString() => nameof(Convolver3ChanIntrinsic);
	}

	internal sealed partial class Convolver3ChanVector : IVectorConvolver
	{
		IConvolver IVectorConvolver.IntrinsicImpl => Sse.IsSupported ? Convolver3ChanIntrinsic.Instance : (IConvolver)this;
	}

	internal sealed partial class Convolver1ChanIntrinsic : IConvolver
	{
		private const int channels = 1;

		public static readonly Convolver1ChanIntrinsic Instance = new();

		private Convolver1ChanIntrinsic() { }

		int IConvolver.Channels => channels;
		int IConvolver.MapChannels => channels;

		[MethodImpl(MethodImplOptions.AggressiveOptimization)]
		unsafe void IConvolver.ConvolveSourceLine(byte* istart, byte* tstart, nint cb, byte* mapxstart, int smapx, int smapy)
		{
			float* tp = (float*)tstart, tpe = (float*)(tstart + cb);
			uint* pmapx = (uint*)mapxstart;
			nint kstride = smapx * channels;
			nint tstride = smapy * channels;
			nint vcnt = kstride / VectorSse.Count;

			while (tp < tpe)
			{
				nint lcnt = vcnt;
				nuint ix = *pmapx++;

				float* ip = (float*)istart + ix * channels;
				float* mp = (float*)(mapxstart + *pmapx++);

				VectorSse av0, av1;
				if (Avx.IsSupported && lcnt >= 4)
				{
					var ax0 = VectorAvx.Zero;
					var ax1 = VectorAvx.Zero;

					do
					{
						lcnt -= 4;

						var iv0 = Avx.LoadVector256(ip);
						var iv1 = Avx.LoadVector256(ip + VectorAvx.Count);
						ip += VectorAvx.Count * 2;

						ax0 = HWIntrinsics.MultiplyAdd(ax0, iv0, mp);
						ax1 = HWIntrinsics.MultiplyAdd(ax1, iv1, mp + VectorAvx.Count);
						mp += VectorAvx.Count * 2;

					} while (lcnt >= 4);

					ax0 = Avx.Add(ax0, ax1);

					if (lcnt >= 2)
					{
						lcnt -= 2;

						var iv0 = Avx.LoadVector256(ip);
						ip += VectorAvx.Count;

						ax0 = HWIntrinsics.MultiplyAdd(ax0, iv0, mp);
						mp += VectorAvx.Count;
					}

					av0 = Sse.Add(ax0.GetLower(), ax0.GetUpper());
				}
				else
				{
					av0 = av1 = VectorSse.Zero;

					while (lcnt >= 2)
					{
						lcnt -= 2;

						var iv0 = Sse.LoadVector128(ip);
						var iv1 = Sse.LoadVector128(ip + VectorSse.Count);
						ip += VectorSse.Count * 2;

						av0 = HWIntrinsics.MultiplyAdd(av0, iv0, mp);
						av1 = HWIntrinsics.MultiplyAdd(av1, iv1, mp + VectorSse.Count);
						mp += VectorSse.Count * 2;
					}

					av0 = Sse.Add(av0, av1);
				}

				if (lcnt != 0)
				{
					var iv0 = Sse.LoadVector128(ip);

					av0 = HWIntrinsics.MultiplyAdd(av0, iv0, mp);
				}

				*tp = av0.HorizontalAdd();
				tp += tstride;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveOptimization)]
		unsafe void IConvolver.WriteDestLine(byte* tstart, byte* ostart, int ox, int ow, byte* pmapy, int smapy)
		{
			float* op = (float*)ostart;
			nint tstride = smapy * channels;
			nint vcnt = tstride / VectorSse.Count;

			for (nint nox = ox, xc = nox + ow; nox < xc; nox++)
			{
				nint lcnt = vcnt;

				float* tp = (float*)tstart + nox * tstride;
				float* mp = (float*)pmapy;

				VectorSse av0, av1;
				if (Avx.IsSupported && lcnt >= 4)
				{
					var ax0 = VectorAvx.Zero;
					var ax1 = VectorAvx.Zero;

					do
					{
						lcnt -= 4;

						var iv0 = Avx.LoadVector256(tp);
						var iv1 = Avx.LoadVector256(tp + VectorAvx.Count);
						tp += VectorAvx.Count * 2;

						ax0 = HWIntrinsics.MultiplyAdd(ax0, iv0, mp);
						ax1 = HWIntrinsics.MultiplyAdd(ax1, iv1, mp + VectorAvx.Count);
						mp += VectorAvx.Count * 2;

					} while (lcnt >= 4);

					ax0 = Avx.Add(ax0, ax1);

					if (lcnt >= 2)
					{
						lcnt -= 2;

						var iv0 = Avx.LoadVector256(tp);
						tp += VectorAvx.Count;

						ax0 = HWIntrinsics.MultiplyAdd(ax0, iv0, mp);
						mp += VectorAvx.Count;
					}

					av0 = Sse.Add(ax0.GetLower(), ax0.GetUpper());
				}
				else
				{
					av0 = av1 = VectorSse.Zero;

					while (lcnt >= 2)
					{
						lcnt -= 2;

						var iv0 = Sse.LoadVector128(tp);
						var iv1 = Sse.LoadVector128(tp + VectorSse.Count);
						tp += VectorSse.Count * 2;

						av0 = HWIntrinsics.MultiplyAdd(av0, iv0, mp);
						av1 = HWIntrinsics.MultiplyAdd(av1, iv1, mp + VectorSse.Count);
						mp += VectorSse.Count * 2;
					}

					av0 = Sse.Add(av0, av1);
				}

				if (lcnt != 0)
				{
					var iv0 = Sse.LoadVector128(tp);

					av0 = HWIntrinsics.MultiplyAdd(av0, iv0, mp);
				}

				*op++ = av0.HorizontalAdd();
			}
		}

		public override string ToString() => nameof(Convolver1ChanIntrinsic);
	}

	internal sealed partial class Convolver1ChanVector : IVectorConvolver
	{
		IConvolver IVectorConvolver.IntrinsicImpl => Sse.IsSupported ? Convolver1ChanIntrinsic.Instance : (IConvolver)this;
	}
}
#endif
